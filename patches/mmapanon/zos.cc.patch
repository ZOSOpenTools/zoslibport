diff --git a/src/zos.cc b/src/zos.cc
index 00ff7b0..ee43609 100644
--- a/src/zos.cc
+++ b/src/zos.cc
@@ -1479,11 +1479,6 @@ extern "C" void *__zalloc(size_t len, size_t alignment) {
   }
 }
 
-void *anon_mmap(void *_, size_t len) {
-  void *p = __zalloc(len, PAGE_SIZE);
-  return (p == nullptr) ? MAP_FAILED : p;
-}
-
 extern "C" int __zfree(void *addr, int len) {
   if (__get_galloc_info()->is_rmode64(addr)) {
     return __get_galloc_info()->free_seg(addr, len);
@@ -1495,8 +1490,105 @@ extern "C" int __zfree(void *addr, int len) {
   return 0;
 }
 
-int anon_munmap(void *addr, size_t len) {
-  return __zfree(addr, len);
+static int dbgmmap = -1;
+static int dbgmmaprequested() {
+  char* dbgset = getenv("ZOSLIB_DEBUG_MMAP");
+  if (!strcmp(dbgset, "1") || !strcmp(dbgset, "Y") || !strcmp(dbgset, "y")) {
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+struct mmap_hdr {
+  void* stg;
+  struct free_chunk* chunk_head;
+  uint64_t stg_len;
+  uint64_t eye_catcher;
+};
+
+// MMAPUMAP in EBCDIC
+#define MMAPUMAP (0xD4D4C1D7E4D4C1D7ULL)
+
+// extending the z/OS mmap when linked statically
+extern "C" void *zoslib_mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset) {
+  // Validate flags are acceptable
+  if (dbgmmap < 0) {
+    dbgmmap = dbgmmaprequested();
+  }
+  if (dbgmmap > 0) {
+    fprintf(stderr, "ZOSLIB DEBUG: mmap to %p of len %zu with prot 0x%x and flags 0x%x filedes:%d, offset:%zu\n", addr, length, prot, flags, fd, offset);
+  }
+
+  // Allocate header for both anonymous and non-anonymous mmap requests
+
+  if (flags & MAP_ANONYMOUS == 0) {
+    // NOT anonymous - just return call to mmap
+    return zos_mmap(addr, length, prot, flags, fd, offset);
+  }
+
+
+  // anonymous - need to ignore the fd and offset fields
+  // currently only support prot of PROT_READ | PROT_WRITE and flags of MAP_PRIVATE | MAP_ANONYMOUS when anonymous requested
+  if (
+      ((prot & (PROT_READ | PROT_WRITE )) != (PROT_READ | PROT_WRITE )) || 
+      ((flags & (MAP_ANONYMOUS | MAP_PRIVATE )) != (MAP_ANONYMOUS | MAP_PRIVATE ))
+     ) {
+    if (dbgmmap > 0) {
+      fprintf(stderr, "ZOSLIB DEBUG: anonymous mmap only supports prot of 0x%x and flags of 0x%x but 0x%x and 0x%x given\n", 
+        PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, prot, flags);
+    }
+    errno = EINVAL;
+    return MAP_FAILED;
+  }
+
+  // This is a supported anonymous mmap request
+
+  struct mmap_hdr* hdr = (struct mmap_hdr*) calloc(length + sizeof(struct mmap_hdr), 1);
+  if (!hdr) {
+    if (dbgmmap > 0) {
+      fprintf(stderr, "ZOSLIB DEBUG: mmap allocation failure. Issuing stack trace\n");
+      ctrace(""); // print out stack trace
+    }
+    return MAP_FAILED;
+  }
+  void* ptr = (void*) (hdr+1);
+  hdr->stg = ptr;
+  hdr->chunk_head = NULL;
+  hdr->stg_len = length;
+  hdr->eye_catcher = MMAPUMAP;
+
+  if (dbgmmap > 0) {
+    fprintf(stderr, "ZOSLIB DEBUG: anonymous mmap. hdr: %p. returned ptr: %p user len %zu\n", hdr, ptr, length);
+  }
+  return ptr;
+}
+
+// extending the z/OS munmap when linked statically
+extern "C" int zoslib_munmap(void *addr, size_t len) {
+  if (dbgmmap < 0) {
+    dbgmmap = dbgmmaprequested();
+  }
+  if (dbgmmap > 0) {
+    fprintf(stderr, "ZOSLIB DEBUG: munmap to %p of len %zu\n", addr, len);
+  }
+
+  struct mmap_hdr* hdr = (struct mmap_hdr*) addr;
+  --hdr;
+
+  if (dbgmmap > 0) {
+    fprintf(stderr, "ZOSLIB DEBUG: anonymous munmap to %p of len %zu hdr: %p [%lx]\n", addr, len, hdr, hdr->eye_catcher);
+  }
+  if ((addr != NULL) && (hdr->eye_catcher == MMAPUMAP) && (hdr->stg_len == len)) {
+    // This is safe to free - full unmap of map'ed storage
+    free(hdr);
+    return 0;
+  }
+  // do not free storage - it could be unmapping just 'part' of the mapped storage - memory leak..
+  if (dbgmmap > 0) {
+    fprintf(stderr, "ZOSLIB DEBUG: anonymous munmap - unable to safely free storage for %p len %zu\n", addr, len);
+  }
+  return 0;
 }
 
 extern "C" int execvpe(const char *name, char *const argv[],
