diff --git a/src/zos.cc b/src/zos.cc
index 00ff7b0..90db3bc 100644
--- a/src/zos.cc
+++ b/src/zos.cc
@@ -1479,11 +1479,6 @@ extern "C" void *__zalloc(size_t len, size_t alignment) {
   }
 }
 
-void *anon_mmap(void *_, size_t len) {
-  void *p = __zalloc(len, PAGE_SIZE);
-  return (p == nullptr) ? MAP_FAILED : p;
-}
-
 extern "C" int __zfree(void *addr, int len) {
   if (__get_galloc_info()->is_rmode64(addr)) {
     return __get_galloc_info()->free_seg(addr, len);
@@ -1495,8 +1490,55 @@ extern "C" int __zfree(void *addr, int len) {
   return 0;
 }
 
-int anon_munmap(void *addr, size_t len) {
-  return __zfree(addr, len);
+extern "C" void* anon_mmap(void *addr, size_t len) {
+  #if 0
+    fprintf(stdout, "mmap anonymous to %p of len %zu with prot 0x%x and flags 0x%x filedes:%d, offset:%zu\n", addr, len, prot, flags, fildes, off);
+  #endif
+  int* ptr = (int*) calloc(len+4, 1);
+  ptr[0] = 0xDEADBEEF;
+  return (void*) &ptr[1];
+}
+
+extern "C" int anon_munmap(void *addr, size_t len) {
+  int* ptr = (int*) addr;
+  if (ptr[-1] == 0xDEADBEEF) {
+  #if 0
+    fprintf(stdout, "munmap anonymous of %p and %zu\n", addr, len);
+  #endif
+    /* do not free storage - it could be unmapping just 'part' of the mapped storage - memory leak... */
+    /* free(&ptr[-1]); */
+    return 0;
+  } else {
+    /* this is a pair from anon_mmap for RO storage */
+    return __zfree(addr, len); 
+  }
+}
+
+// extending the z/OS mmap when linked statically
+extern "C" void *zoslib_mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset) {
+  // Validate flags are acceptable
+  if (flags & MAP_ANONYMOUS) {
+    // anonymous - need to ignore the fd and offset fields
+    // currently only support PROT_READ | PROT_WRITE | MAP_PRIVATE for anonymous
+    if ((flags & (MAP_ANONYMOUS | PROT_READ | PROT_WRITE | MAP_PRIVATE )) != (MAP_ANONYMOUS | PROT_READ | PROT_WRITE | MAP_PRIVATE )) {
+      errno = EINVAL;
+      return NULL;
+    }
+    return anon_mmap(addr, length);
+  } else {
+    return zos_mmap(addr, length, prot, flags, fd, offset);
+  }
+}
+
+// extending the z/OS munmap when linked statically
+extern "C" int zoslib_unmap(void *addr, size_t len) {
+  // Check if this is an anonymous mmap
+  int* ptr = (int*) addr;
+  if (ptr[-1] == 0xDEADBEEF) {
+    return anon_munmap(addr, len);
+  } else {
+    return zos_unmap(addr, len);
+  }
 }
 
 extern "C" int execvpe(const char *name, char *const argv[],
