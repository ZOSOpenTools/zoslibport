diff --git a/src/zos.cc b/src/zos.cc
index 00ff7b0..0925051 100644
--- a/src/zos.cc
+++ b/src/zos.cc
@@ -1479,11 +1479,6 @@ extern "C" void *__zalloc(size_t len, size_t alignment) {
   }
 }
 
-void *anon_mmap(void *_, size_t len) {
-  void *p = __zalloc(len, PAGE_SIZE);
-  return (p == nullptr) ? MAP_FAILED : p;
-}
-
 extern "C" int __zfree(void *addr, int len) {
   if (__get_galloc_info()->is_rmode64(addr)) {
     return __get_galloc_info()->free_seg(addr, len);
@@ -1495,8 +1490,95 @@ extern "C" int __zfree(void *addr, int len) {
   return 0;
 }
 
-int anon_munmap(void *addr, size_t len) {
-  return __zfree(addr, len);
+static int dbgmmap = -1;
+static int dbgmmaprequested() {
+  char* dbgset = getenv("ZOSLIB_DEBUG_MMAP");
+  if (!strcmp(dbgset, "1") || !strcmp(dbgset, "Y") || !strcmp(dbgset, "y")) {
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+extern "C" void* anon_mmap(void *addr, size_t len) {
+  int* ptr = (int*) calloc(len+32, 1); /* keep storage aligned at double-word boundary */
+  if (dbgmmap > 0) {
+    fprintf(stderr, "ZOSLIB DEBUG: anonymous mmap of ptr: %p len %zu gives: %p\n", addr, len, ptr);
+  }
+  if (ptr) {
+    ptr[3] = 0xDEADBEEF;
+    return (void*) &ptr[4];
+  } else {
+    if (dbgmmap > 0) {
+      fprintf(stderr, "ZOSLIB DEBUG: Issuing stack trace\n");
+      ctrace(""); // print out stack trace
+    }
+    return MAP_FAILED;
+  }
+}
+
+extern "C" int anon_munmap(void *addr, size_t len) {
+  int* ptr = (int*) addr;
+  if (dbgmmap > 0) {
+    fprintf(stderr, "ZOSLIB DEBUG: anonymous munmap to %p of len %zu ptr[-1]: %x\n", addr, len, ptr[-1]);
+  }
+  if (ptr[-1] == 0xDEADBEEF) {
+    /* do not free storage - it could be unmapping just 'part' of the mapped storage - memory leak... */
+    /* free(&ptr[-4]); */
+    return 0;
+  } else {
+    /* this might be a pair from anon_mmap for RO storage */
+    /* for now, still can't free storage because it could be in the middle of mmap'ed storage - for now do not free */
+    return 0;
+  }
+}
+
+// extending the z/OS mmap when linked statically
+extern "C" void *zoslib_mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset) {
+  // Validate flags are acceptable
+  if (dbgmmap < 0) {
+    dbgmmap = dbgmmaprequested();
+  }
+  if (dbgmmap > 0) {
+    fprintf(stderr, "ZOSLIB DEBUG: mmap to %p of len %zu with prot 0x%x and flags 0x%x filedes:%d, offset:%zu\n", addr, length, prot, flags, fd, offset);
+  }
+  if (flags & MAP_ANONYMOUS) {
+    // anonymous - need to ignore the fd and offset fields
+    // currently only support prot of PROT_READ | PROT_WRITE and flags of MAP_PRIVATE | MAP_ANONYMOUS when anonymous requested
+    if (
+        ((prot & (PROT_READ | PROT_WRITE )) != (PROT_READ | PROT_WRITE )) || 
+        ((flags & (MAP_ANONYMOUS | MAP_PRIVATE )) != (MAP_ANONYMOUS | MAP_PRIVATE ))
+       ) {
+      if (dbgmmap > 0) {
+        fprintf(stderr, "ZOSLIB DEBUG: anonymous mmap only supports prot of 0x%x and flags of 0x%x but 0x%x and 0x%x given\n", 
+          PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, prot, flags);
+      }
+      errno = EINVAL;
+      return MAP_FAILED;
+    }
+    return anon_mmap(addr, length);
+  } else {
+    return zos_mmap(addr, length, prot, flags, fd, offset);
+  }
+}
+
+// extending the z/OS munmap when linked statically
+extern "C" int zoslib_munmap(void *addr, size_t len) {
+  if (dbgmmap < 0) {
+    dbgmmap = dbgmmaprequested();
+  }
+  if (dbgmmap > 0) {
+    fprintf(stderr, "ZOSLIB DEBUG: munmap to %p of len %zu\n", addr, len);
+  }
+
+  // Check if this is an anonymous mmap
+  int* ptr = (int*) addr;
+  if (ptr[-1] == 0xDEADBEEF) {
+    return anon_munmap(addr, len);
+  } else {
+    /* not smart enough to recognize munmap 'inside' storage area return zos_munmap(addr, len); */
+    return 0;
+  }
 }
 
 extern "C" int execvpe(const char *name, char *const argv[],
